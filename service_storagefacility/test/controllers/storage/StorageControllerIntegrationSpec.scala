package controllers.storage

import models.storage.nodes.StorageType._
import models.storage.nodes._
import no.uio.musit.formatters.DateTimeFormatters.dateTimeFormatter
import no.uio.musit.models._
import no.uio.musit.security.BearerToken
import no.uio.musit.test.{FakeUsers, MusitSpecWithServerPerSuite}
import org.joda.time.DateTime
import play.api.libs.json._
import play.api.libs.ws.WSResponse
import play.api.test.Helpers._
import utils.testhelpers.StorageNodeJsonGenerator._
import utils.testhelpers._

/**
 * TODO: These tests are still somewhat fragile in that some of them
 * depend on ID's generated by the previously executed test cases.
 */
class StorageControllerIntegrationSpec extends MusitSpecWithServerPerSuite {

  val insertedNodeIds = Map.newBuilder[Long, StorageNodeId]

  val mid = MuseumId(99)

  val readToken  = BearerToken(FakeUsers.testUserToken)
  val writeToken = BearerToken(FakeUsers.testWriteToken)
  val writeId    = ActorId.unsafeFromString(FakeUsers.testWriteId)
  val adminToken = BearerToken(FakeUsers.testAdminToken)
  val adminId    = ActorId.unsafeFromString(FakeUsers.testAdminId)
  val godToken   = BearerToken(FakeUsers.superUserToken)

  def getIdFor(num: Long): Option[StorageNodeId] = insertedNodeIds.result().get(num)

  def getIdStringFor(num: Long): String = getIdFor(num).map(_.asString).getOrElse("")

  def getIdFor(num: Int): Option[StorageNodeId] = getIdFor(num.toLong)

  def getIdStringFor(num: Int): String = getIdFor(num).map(_.asString).getOrElse("")

  def verifyNode[T <: StorageNode](
      response: WSResponse,
      expStorageType: StorageType,
      expName: String,
      expId: Long,
      expPartOf: Option[Long] = None
  )(implicit manifest: Manifest[T]): T = {
    val storageNode = parseAndVerifyResponse[T](response).value
    // verifying common attributes across all storage node types
    storageNode.id mustBe Some(StorageNodeDatabaseId(expId))
    storageNode.nodeId must not be empty
    storageNode.storageType mustBe expStorageType
    storageNode.isPartOf mustBe expPartOf.map(StorageNodeDatabaseId.apply)
    storageNode.name mustBe expName
    storageNode mustBe a[T]

    storageNode
  }

  def parseAndVerifyResponse[T](response: WSResponse): Option[T] = {
    val json   = Json.parse(response.body)
    val parsed = json.validate[StorageNode]
    parsed.isSuccess mustBe true
    parsed.asOpt.map(_.asInstanceOf[T])
  }

  def postNode(mid: Int, token: BearerToken, js: JsValue): (WSResponse, Long) = {
    val res =
      wsUrl(StorageNodesUrl(mid)).withHeaders(token.asHeader).post(js).futureValue
    res.status mustBe CREATED
    val ids = (res.json \ "id").as[Long] -> (res.json \ "nodeId").as[String]

    insertedNodeIds += ids._1.toLong -> StorageNodeId.unsafeFromString(ids._2)

    (res, ids._1)
  }

  // TODO: add override def beforeTests to bootstrap a re-usable structure to
  // avoid boilerplate bootstrapping in all the tests.

  "Interacting with the StorageController endpoints" should {

    "successfully create a few root nodes" in {

      def genAndAddRootNode(mid: Int, numNodes: Int, from: Int = 1): Seq[Root] = {
        val fromIncInserted = from + 17
        val addedNodes      = Seq.newBuilder[Root]
        for (i <- fromIncInserted until numNodes + fromIncInserted) {
          val res = wsUrl(RootNodeUrl(mid))
            .withHeaders(godToken.asHeader)
            .post(rootJson(s"root-$i"))
            .futureValue
          val root = parseAndVerifyResponse[Root](res).value
          root mustBe a[Root]
          root.id.isEmpty must not be true
          root.id.value mustBe StorageNodeDatabaseId(i.toLong)
          root.nodeId must not be empty

          insertedNodeIds += (root.id.value.underlying -> root.nodeId.value)

          root.storageType mustBe StorageType.RootType
          val rootId = root.id.value
          root.path mustBe NodePath(s",${rootId.underlying},")
          addedNodes += root
        }
        addedNodes.result()
      }

      genAndAddRootNode(mid, 2).size mustBe 2
      genAndAddRootNode(4, 2, 3).size mustBe 2
    }

    "successfully create an organisation node" in {
      val json     = organisationJson("My Org1", Some(StorageNodeDatabaseId(1)))
      val response = postNode(mid, adminToken, json)

      val organisation = verifyNode[Organisation](
        response._1,
        OrganisationType,
        "My Org1",
        22,
        Some(1)
      )
      organisation mustBe an[Organisation]
      organisation.path mustBe NodePath(",1,22,")
      organisation.updatedBy mustBe Some(adminId)
      organisation.updatedDate.value.year() mustBe DateTime.now().year()
    }

    "successfully create a building node" in {
      val json     = buildingJson("My Building1", StorageNodeDatabaseId(22))
      val response = postNode(mid, adminToken, json)

      val building = verifyNode[Building](
        response._1,
        BuildingType,
        "My Building1",
        23,
        Some(22)
      )
      building mustBe a[Building]
      building.path mustBe NodePath(",1,22,23,")
      building.updatedBy.value mustBe adminId
      building.updatedDate.value.year() mustBe DateTime.now().year()
    }

    "successfully create a room node" in {
      val json     = roomJson("My Room1", Some(StorageNodeDatabaseId(23)))
      val response = postNode(mid, adminToken, json)

      val room = verifyNode[Room](
        response._1,
        RoomType,
        "My Room1",
        24,
        Some(23)
      )
      room mustBe a[Room]
      room.path mustBe NodePath(",1,22,23,24,")
      room.updatedBy.value mustBe adminId
      room.updatedDate.value.year() mustBe DateTime.now().year()
    }

    "successfully create a storage unit node" in {
      val json     = storageUnitJson("My Shelf1", StorageNodeDatabaseId(24))
      val response = postNode(mid, adminToken, json)

      val su = verifyNode[StorageUnit](
        response._1,
        StorageUnitType,
        "My Shelf1",
        25,
        Some(24)
      )
      su mustBe a[StorageUnit]
      su.path mustBe NodePath(",1,22,23,24,25,")
      su.updatedBy.value mustBe adminId
      su.updatedDate.value.year() mustBe DateTime.now().year()
    }

    "not allow creating a storage node with a name over 100 chars" in {
      val json = storageUnitJson(HundredAndOneCharString, StorageNodeDatabaseId(7))
      wsUrl(StorageNodesUrl(mid))
        .withHeaders(adminToken.asHeader)
        .post(json)
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "not allow creating a building with an address over 100 chars" in {
      val bjs  = buildingJson("fail", StorageNodeDatabaseId(9))
      val json = bjs.as[JsObject] ++ Json.obj("address" -> HundredAndOneCharString)
      wsUrl(StorageNodesUrl(mid.underlying))
        .withHeaders(adminToken.asHeader)
        .post(json)
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "successfully get an organisation" in {
      val response = wsUrl(StorageNodeUrl(mid, getIdStringFor(22)))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      response.status mustBe OK

      val organisation = verifyNode[Organisation](
        response,
        OrganisationType,
        "My Org1",
        22,
        Some(1)
      )
      organisation mustBe an[Organisation]
    }

    "successfully get a building" in {
      val response = wsUrl(StorageNodeUrl(mid, getIdStringFor(23)))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      response.status mustBe OK

      val building = verifyNode[Building](
        response,
        BuildingType,
        "My Building1",
        23,
        Some(22)
      )
      building mustBe a[Building]
    }

    "successfully get a room" in {
      val nodeId1 =
        StorageNodeId.unsafeFromString("dca44956-40d0-48dc-bd0d-921b825ad019")
      val response = wsUrl(StorageNodeUrl(mid, getIdStringFor(24)))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      response.status mustBe OK

      val room = verifyNode[Room](
        response,
        RoomType,
        "My Room1",
        24,
        Some(23)
      )
      room mustBe a[Room]
      room.environmentRequirement must not be None
      room.path mustBe NodePath(",1,22,23,24,")
      room.pathNames must not be None
      room.pathNames.value must contain allOf (
        // format: off
          NamedPathElement(StorageNodeDatabaseId(1), nodeId1, "Utviklingsmuseet"),
          NamedPathElement(StorageNodeDatabaseId(22), getIdFor(22).value, "My Org1"),
          NamedPathElement(StorageNodeDatabaseId(23), getIdFor(23).value, "My Building1"),
          NamedPathElement(StorageNodeDatabaseId(24), getIdFor(24).value, "My Room1")
          // format: on
      )
    }

    "successfully get a storage unit" in {
      val response = wsUrl(StorageNodeUrl(mid, getIdStringFor(25)))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      response.status mustBe OK

      val su = verifyNode[StorageUnit](
        response,
        StorageUnitType,
        "My Shelf1",
        25,
        Some(24)
      )
      su mustBe a[StorageUnit]
      su.environmentRequirement must not be None
    }

    "not find a storage node with an invalid Id" in {
      wsUrl(StorageNodeUrl(mid, StorageNodeId.generate().asString))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
        .status mustBe NOT_FOUND
    }

    "successfully update a storage unit" in {
      val json     = storageUnitJson("My Shelf2", StorageNodeDatabaseId(24))
      val response = postNode(mid, adminToken, json)

      val su = verifyNode[StorageUnit](
        response._1,
        StorageUnitType,
        "My Shelf2",
        26,
        Some(24)
      )
      su mustBe a[StorageUnit]
      su.path mustBe NodePath(",1,22,23,24,26,")
      su.areaTo mustBe Some(.5)
      su.heightTo mustBe Some(.6)

      val updatedJson = {
        Json.parse(response._1.body).as[JsObject] ++ Json.obj(
          "name"     -> "My Shelf2b",
          "areaTo"   -> JsNumber(.8),
          "heightTo" -> JsNumber(.8)
        )
      }

      val updRes = wsUrl(StorageNodeUrl(mid, getIdStringFor(26)))
        .withHeaders(adminToken.asHeader)
        .put(updatedJson)
        .futureValue
      updRes.status mustBe OK
      val updated = verifyNode[StorageUnit](
        updRes,
        StorageUnitType,
        "My Shelf2b",
        su.id.value,
        Some(24)
      )

      updated mustBe a[StorageUnit]
      updated.path mustBe NodePath(",1,22,23,24,26,")
      updated.areaTo mustBe Some(.8)
      updated.heightTo mustBe Some(.8)
      updated.updatedBy.value mustBe adminId
    }

    "successfully update a room" in {
      val nodeId1 =
        StorageNodeId.unsafeFromString("dca44956-40d0-48dc-bd0d-921b825ad019")

      val json     = roomJson("My Room2", Some(StorageNodeDatabaseId(23)))
      val response = postNode(mid, adminToken, json)

      val room = verifyNode[Room](
        response._1,
        RoomType,
        "My Room2",
        27,
        Some(23)
      )
      room mustBe a[Room]
      room.path mustBe NodePath(",1,22,23,27,")
      room.areaTo mustBe Some(21.0)
      room.heightTo mustBe Some(2.6)

      val updatedJson = {
        Json.parse(response._1.body).as[JsObject] ++ Json.obj(
          "name"              -> "My Room2b",
          "lightingCondition" -> true
        )
      }

      val updRes = wsUrl(StorageNodeUrl(mid, getIdStringFor(27)))
        .withHeaders(adminToken.asHeader)
        .put(updatedJson)
        .futureValue
      updRes.status mustBe OK
      val updated = verifyNode[Room](
        updRes,
        RoomType,
        "My Room2b",
        room.id.value,
        Some(23)
      )

      updated mustBe a[Room]
      updated.path mustBe NodePath(",1,22,23,27,")
      updated.environmentAssessment.lightingCondition mustBe Some(true)
      updated.pathNames must not be None
      updated.pathNames.value must contain allOf (
        NamedPathElement(
          StorageNodeDatabaseId(1),
          nodeId1,
          "Utviklingsmuseet"
        ),
        NamedPathElement(StorageNodeDatabaseId(22), getIdFor(22).value, "My Org1"),
        NamedPathElement(
          StorageNodeDatabaseId(23),
          getIdFor(23).value,
          "My Building1"
        ),
        NamedPathElement(StorageNodeDatabaseId(27), getIdFor(27).value, "My Room2b")
      )
      updated.updatedBy.value mustBe adminId
    }

    "successfully update a building with environment requirements" in {
      val json     = buildingJson("My Building2", StorageNodeDatabaseId(22))
      val response = postNode(mid, adminToken, json)
      val building = verifyNode[Building](
        response._1,
        BuildingType,
        "My Building2",
        28,
        Some(22)
      )
      building mustBe a[Building]
      building.path mustBe NodePath(",1,22,28,")
      building.areaTo mustBe Some(210.0)
      building.heightTo mustBe Some(3.5)

      val updatedJson = {
        Json.parse(response._1.body).as[JsObject] ++ Json.obj(
          "address"                -> "Fjære Åker Øya 21, 2341 Huttiheita, Norge",
          "environmentRequirement" -> Json.parse(envReqJson("Filthy"))
        )
      }

      val updRes = wsUrl(StorageNodeUrl(mid, getIdStringFor(28)))
        .withHeaders(adminToken.asHeader)
        .put(updatedJson)
        .futureValue
      updRes.status mustBe OK
      val updated = verifyNode[Building](
        updRes,
        BuildingType,
        "My Building2",
        building.id.value,
        Some(22)
      )

      updated mustBe a[Building]
      updated.path mustBe NodePath(",1,22,28,")
      updated.address mustBe Some("Fjære Åker Øya 21, 2341 Huttiheita, Norge")
      updated.environmentRequirement.isEmpty must not be true
      updated.environmentRequirement.value.cleaning mustBe Some("Filthy")
      updated.updatedBy.value mustBe adminId

    }

    "successfully update an organisation" in {
      val json     = organisationJson("My Organisation2", Some(StorageNodeDatabaseId(1)))
      val response = postNode(mid, adminToken, json)

      val organisation = verifyNode[Organisation](
        response._1,
        OrganisationType,
        "My Organisation2",
        29,
        Some(1)
      )
      organisation mustBe an[Organisation]
      organisation.path mustBe NodePath(",1,29,")
      organisation.areaTo mustBe Some(2100)
      organisation.heightTo mustBe Some(3.5)

      val updatedJson = {
        Json.parse(response._1.body).as[JsObject] ++ Json.obj(
          "address" -> "Fjære Åker Øya 21, 2341 Huttiheita, Norge"
        )
      }

      val updRes = wsUrl(StorageNodeUrl(mid, getIdStringFor(29)))
        .withHeaders(adminToken.asHeader)
        .put(updatedJson)
        .futureValue
      updRes.status mustBe OK
      val updated = verifyNode[Organisation](
        updRes,
        OrganisationType,
        "My Organisation2",
        organisation.id.value,
        organisation.isPartOf
      )

      updated mustBe an[Organisation]
      updated.path mustBe NodePath(",1,29,")
      updated.address mustBe Some("Fjære Åker Øya 21, 2341 Huttiheita, Norge")
      updated.updatedBy.value mustBe adminId
    }

    "respond with 404 when trying to update a node that doesn't exist" in {
      val badId = StorageNodeId.generate().asString
      val json = Json.obj("id" -> 123, "nodeId" -> badId) ++
        storageUnitJson("Non existent", StorageNodeDatabaseId(333)).as[JsObject]

      val res = wsUrl(StorageNodeUrl(mid, badId))
        .withHeaders(adminToken.asHeader)
        .put(json)
        .futureValue

      res.status mustBe NOT_FOUND
    }

    "list all children for a node with correct storage types" in {
      // fetch children for nodeId = 1
      val res = wsUrl(NodeChildrenUrl(mid, "dca44956-40d0-48dc-bd0d-921b825ad019"))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      res.status mustBe OK
      (res.json \ "totalMatches").as[Int] mustBe 3
      (res.json \ "matches").as[JsArray].value.foreach { jsv =>
        (jsv \ "type").as[String] mustBe "Organisation"
      }
    }

    "successfully delete a storage node" in {
      val json = storageUnitJson("Remove me", StorageNodeDatabaseId(24))
      val res  = postNode(mid, adminToken, json)
      val created = verifyNode[StorageUnit](
        res._1,
        StorageUnitType,
        "Remove me",
        30,
        Some(24)
      )

      created mustBe a[StorageUnit]

      val rmRes = wsUrl(StorageNodeUrl(mid, getIdStringFor(30)))
        .withHeaders(adminToken.asHeader)
        .delete()
        .futureValue
      rmRes.status mustBe OK

      val notFound = wsUrl(StorageNodeUrl(mid, getIdStringFor(30)))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      notFound.status mustBe NOT_FOUND
    }

    "respond with 404 when deleting a node that doesn't exist" in {
      wsUrl(StorageNodeUrl(mid, StorageNodeId.generate().asString))
        .withHeaders(adminToken.asHeader)
        .delete()
        .futureValue
        .status mustBe NOT_FOUND
    }

    "respond with 404 when deleting a node that is already deleted" in {
      wsUrl(StorageNodeUrl(mid, getIdStringFor(30)))
        .withHeaders(adminToken.asHeader)
        .delete()
        .futureValue
        .status mustBe NOT_FOUND
    }

    "respond with 404 when updating a node that is deleted" in {
      val json = {
        storageUnitJson("Remove me", StorageNodeDatabaseId(28)).as[JsObject] ++ Json.obj(
          "id"   -> 30,
          "name" -> "Hakuna Matata"
        )
      }
      wsUrl(StorageNodeUrl(mid, getIdStringFor(30)))
        .withHeaders(adminToken.asHeader)
        .put(json)
        .futureValue
        .status mustBe NOT_FOUND
    }

    "successfully move a single node" in {
      val json = storageUnitJson("Move me", StorageNodeDatabaseId(24))
      val res  = postNode(mid, adminToken, json)

      val created = verifyNode[StorageUnit](
        res._1,
        StorageUnitType,
        "Move me",
        31,
        Some(24)
      )

      created mustBe a[StorageUnit]
      created.path mustBe NodePath(",1,22,23,24,31,")

      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "${getIdStringFor(26)}",
             |  "items": ["${getIdStringFor(31)}"]
             |}""".stripMargin
      )

      val moveRes = wsUrl(MoveStorageNodeUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
      moveRes.status mustBe OK

      // format: off
      (moveRes.json \ "moved").as[JsArray].value.head.as[String] mustBe getIdStringFor(31)
      // format: on

      val movedNodeRes = wsUrl(StorageNodeUrl(mid, getIdStringFor(31)))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      val moved = verifyNode[StorageUnit](
        movedNodeRes,
        StorageUnitType,
        "Move me",
        31,
        Some(26)
      )
      moved mustBe a[StorageUnit]
      moved.path mustBe NodePath(",1,22,23,24,26,31,")
    }

    "fail when trying to move a node to an invalid destination" in {
      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "${getIdStringFor(31)}",
             |  "items": ["${getIdStringFor(24)}"]
             |}""".stripMargin
      )
      wsUrl(MoveStorageNodeUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "successfully move several nodes" in {
      val json1 = storageUnitJson("Move me1", StorageNodeDatabaseId(24))
      val json2 = storageUnitJson("Move me2", StorageNodeDatabaseId(24))
      val json3 = storageUnitJson("Move me3", StorageNodeDatabaseId(24))
      val res1  = postNode(mid, adminToken, json1)
      val res2  = postNode(mid, adminToken, json2)
      val res3  = postNode(mid, adminToken, json3)

      val id1 = getIdStringFor(res1._2)
      val id2 = getIdStringFor(res2._2)
      val id3 = getIdStringFor(res3._2)

      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "${getIdStringFor(26)}",
             |  "items": ["$id1", "$id2", "$id3"]
             |}""".stripMargin
      )

      val move = wsUrl(MoveStorageNodeUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
      move.status mustBe OK

      val movedRes1 =
        wsUrl(StorageNodeUrl(mid, id1)).withHeaders(readToken.asHeader).get().futureValue
      val movedRes2 =
        wsUrl(StorageNodeUrl(mid, id2)).withHeaders(readToken.asHeader).get().futureValue
      val movedRes3 =
        wsUrl(StorageNodeUrl(mid, id3)).withHeaders(readToken.asHeader).get().futureValue

      val n1 = verifyNode[StorageUnit](
        movedRes1,
        StorageUnitType,
        "Move me1",
        res1._2,
        Some(26)
      )
      val n2 = verifyNode[StorageUnit](
        movedRes2,
        StorageUnitType,
        "Move me2",
        res2._2,
        Some(26)
      )
      val n3 = verifyNode[StorageUnit](
        movedRes3,
        StorageUnitType,
        "Move me3",
        res3._2,
        Some(26)
      )

      n1.path mustBe NodePath(s",1,22,23,24,26,${res1._2},")
      n2.path mustBe NodePath(s",1,22,23,24,26,${res2._2},")
      n3.path mustBe NodePath(s",1,22,23,24,26,${res3._2},")
    }

    "fail when trying to move several nodes to an invalid destination" in {
      val json1 = storageUnitJson("Move me1", StorageNodeDatabaseId(24))
      val json2 = storageUnitJson("Move me2", StorageNodeDatabaseId(24))
      val json3 = storageUnitJson("Move me3", StorageNodeDatabaseId(24))
      val res1  = postNode(mid, adminToken, json1)
      val res2  = postNode(mid, adminToken, json2)
      val res3  = postNode(mid, adminToken, json3)

      val id1 = getIdStringFor(res1._2)
      val id2 = getIdStringFor(res2._2)
      val id3 = getIdStringFor(res3._2)

      val moveJson = Json.parse(
        // dca44956-40d0-48dc-bd0d-921b825ad019 = StorageNodeDatabaseId(1)
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "dca44956-40d0-48dc-bd0d-921b825ad019",
             |  "items": ["$id1", "$id2", "$id3"]
             |}""".stripMargin
      )
      wsUrl(MoveStorageNodeUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "successfully move a node and all its children" in {
      val res1 =
        wsUrl(NodeChildrenUrl(mid, getIdStringFor(26)))
          .withHeaders(readToken.asHeader)
          .get()
          .futureValue
      res1.status mustBe OK
      val directChildIds = (res1.json \ "matches").as[JsArray].value.map { jsv =>
        (jsv \ "nodeId").as[String]
      }

      val subChildrenIds = directChildIds.flatMap { id =>
        val r = wsUrl(NodeChildrenUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get()
          .futureValue
        r.status mustBe OK
        (r.json \ "matches").as[JsArray].value.map { jsv =>
          (jsv \ "id").as[String]
        }
      }

      val verifyIds = directChildIds ++ subChildrenIds
      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "${getIdStringFor(25)}",
             |  "items": ["${getIdStringFor(26)}"]
             |}""".stripMargin
      )

      val moveRes = wsUrl(MoveStorageNodeUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
      moveRes.status mustBe OK
      (moveRes.json \ "moved").as[JsArray].value.map(_.as[String]) must contain(
        getIdStringFor(26)
      )

      val paths = verifyIds.map { id =>
        val r = wsUrl(StorageNodeUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get()
          .futureValue
        r.status mustBe OK
        (
          (r.json \ "id").as[Int],
          (r.json \ "path").as[String],
          (r.json \ "isPartOf").asOpt[Int]
        ) // FIXME: What good does this do?
      }
    }

    "successfully move several objects" in {
      val id1 = "37715843-36ab-4f1a-bcfb-dd68a05d0f2c"
      val id2 = "8ae52969-63b8-42be-bfd0-d8ebef2169eb"
      val id3 = "d43e3c5a-8244-4497-bd15-29c844ff8745"

      val destNode = "244f09a3-eb1a-49e7-80ee-7a07baa016dd" // node 6
      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "$destNode",
             |  "items": [{
             |    "id": "$id1",
             |    "objectType": "collection"
             |  },{
             |    "id": "$id2",
             |    "objectType": "collection"
             |  },{
             |    "id": "$id3",
             |    "objectType": "collection"
             |  }]
             |}""".stripMargin
      )

      val move = wsUrl(MoveObjectUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue

      move.status mustBe OK
      (move.json \ "moved")
        .as[JsArray]
        .value
        .map(_.as[String]) must contain allOf (id1, id2, id3)
    }

    "successfully move a single object" in {
      val id2      = "8ae52969-63b8-42be-bfd0-d8ebef2169eb"
      val destNode = "3562e09e-6cf4-4b27-acad-e655e771c016"

      val res = wsUrl(ObjLocationHistoryUrl(mid, id2))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue

      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "$destNode",
             |  "items": [{
             |    "id": "$id2",
             |    "objectType": "collection"
             |  }]
             |}""".stripMargin
      )
      val move = wsUrl(MoveObjectUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
      move.status mustBe OK
      (move.json \ "moved").as[JsArray].value.map(_.as[String]).head mustBe id2
    }

    "successfully fetch the location history for a given object" in {
      val id2 = "8ae52969-63b8-42be-bfd0-d8ebef2169eb"

      val res = wsUrl(ObjLocationHistoryUrl(mid, id2))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue

      res.status mustBe OK
      val resArr = res.json.as[JsArray].value
      resArr.size mustBe 2

      val today = DateTime.now.withTimeAtStartOfDay()

      val firstElem = resArr.head
      (firstElem \ "doneDate").as[DateTime].withTimeAtStartOfDay() mustBe today
      (firstElem \ "doneBy").as[String] mustBe writeId.asString
      (firstElem \ "registeredDate").as[DateTime].withTimeAtStartOfDay() mustBe today
      (firstElem \ "registeredBy").as[String] mustBe writeId.asString
      (firstElem \ "from" \ "path").as[NodePath] mustBe NodePath(",1,3,4,6,")
      (firstElem \ "from" \ "pathNames").as[JsArray].value must not be empty
      (firstElem \ "to" \ "path").as[NodePath] mustBe NodePath(",1,3,4,")
      (firstElem \ "to" \ "pathNames").as[JsArray].value must not be empty

      val lastElem = resArr.last
      (lastElem \ "doneDate").as[DateTime].withTimeAtStartOfDay() mustBe today
      (lastElem \ "doneBy").as[String] mustBe writeId.asString
      (lastElem \ "registeredDate").as[DateTime].withTimeAtStartOfDay() mustBe today
      (lastElem \ "registeredBy").as[String] mustBe writeId.asString
      (lastElem \ "from" \ "path").as[NodePath] mustBe NodePath(",1,3,4,5,")
      (lastElem \ "from" \ "pathNames").as[JsArray].value must not be empty
      (lastElem \ "to" \ "path").as[NodePath] mustBe NodePath(",1,3,4,6,")
      (lastElem \ "to" \ "pathNames").as[JsArray].value must not be empty
    }

    "successfully get currentLocation of a single object" in {
      val id2      = "8ae52969-63b8-42be-bfd0-d8ebef2169eb"
      val destNode = "01134afe-b262-434b-a71f-8f697bc75e56"

      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "$destNode",
             |  "items": [{
             |    "id": "$id2",
             |    "objectType": "collection"
             |  }]
             |}""".stripMargin
      )

      val move = wsUrl(MoveObjectUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue
      move.status mustBe OK
      (move.json \ "moved").as[JsArray].value.map(_.as[String]).head mustBe id2

      val currentLocation = wsUrl(ObjCurrentLocationUrl(mid, id2))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
      currentLocation.status mustBe OK

      val js = currentLocation.json
      (js \ "nodeId").as[String] mustBe destNode
    }

    "respond with 403 when trying to get a node using wrong museum" in {
      val mid    = MuseumId(5)
      val nodeId = "244f09a3-eb1a-49e7-80ee-7a07baa016dd" // node 6
      val json   = storageUnitJson("Non existent museum", StorageNodeDatabaseId(6))
      val failedUpdate = wsUrl(StorageNodeUrl(mid, nodeId))
        .withHeaders(writeToken.asHeader)
        .put(json)
        .futureValue
      failedUpdate.status mustBe FORBIDDEN
    }

    "respond with 400 when trying to get a node with a museum that doesn't exist" in {
      val mid    = MuseumId(55)
      val nodeId = "6e5b9810-9bbf-464a-a0b9-c27f6095ba0c" // node 7
      val json   = storageUnitJson("Non existent museum", StorageNodeDatabaseId(7))

      val failedUpdate = wsUrl(StorageNodeUrl(mid, nodeId))
        .withHeaders(writeToken.asHeader)
        .put(json)
        .futureValue
      failedUpdate.status mustBe BAD_REQUEST
    }

    "not list all children for a root node with MuseumId that doesn't exist" in {
      val mid    = MuseumId(55)
      val nodeId = "dca44956-40d0-48dc-bd0d-921b825ad019" // node 1
      val res =
        wsUrl(NodeChildrenUrl(mid, nodeId))
          .withHeaders(readToken.asHeader)
          .get()
          .futureValue
      res.status mustBe BAD_REQUEST
    }

    "not list all children for a root node with wrong MuseumId " in {
      val mid    = MuseumId(1)
      val nodeId = "dca44956-40d0-48dc-bd0d-921b825ad019" // node 1
      val res =
        wsUrl(NodeChildrenUrl(mid, nodeId))
          .withHeaders(readToken.asHeader)
          .get()
          .futureValue

      res.status mustBe OK
      (res.json \ "totalMatches").as[Int] mustBe 0
      (res.json \ "matches").as[JsArray].value.size mustBe 0
    }

    "respond with 403 when trying to update a node using wrong MuseumId" in {
      val json     = storageUnitJson("My Shelf2", StorageNodeDatabaseId(7))
      val response = postNode(mid, adminToken, json)
      val id       = getIdStringFor(response._2)

      val updatedJson = response._1.json.as[JsObject] ++ Json.obj(
        "name"     -> "My Shelf2b",
        "areaTo"   -> JsNumber(.8),
        "heightTo" -> JsNumber(.8)
      )

      val wrongMid = MuseumId(4)
      val updRes = wsUrl(StorageNodeUrl(wrongMid, id))
        .withHeaders(adminToken.asHeader)
        .put(updatedJson)
        .futureValue
      updRes.status mustBe FORBIDDEN
    }

    "respond with 403 when trying to delete a node using wrong MuseumId" in {
      val nodeId   = "af08788a-a85a-455f-b762-aa2c328ff90f"
      val wrongMid = MuseumId(4)
      val rmRes = wsUrl(StorageNodeUrl(wrongMid, nodeId))
        .withHeaders(adminToken.asHeader)
        .delete()
        .futureValue
      rmRes.status mustBe FORBIDDEN
    }

    "respond with 400 when trying to delete a node using an invalid MuseumId" in {
      val notExistsMid = MuseumId(55)
      wsUrl(StorageNodeUrl(notExistsMid, getIdStringFor(24)))
        .withHeaders(adminToken.asHeader)
        .delete()
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "respond with 403 when trying to move a node using incorrect MuseumId" in {
      val json = storageUnitJson("Move me", StorageNodeDatabaseId(7))
      val res1 = postNode(mid, adminToken, json)

      val moveMeId = getIdStringFor(res1._2)

      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "${getIdStringFor(24)}",
             |  "items": ["$moveMeId"]
             |}""".stripMargin
      )

      val wrongMid = MuseumId(4)
      val moveRes = wsUrl(MoveStorageNodeUrl(wrongMid))
        .withHeaders(adminToken.asHeader)
        .put(moveJson)
        .futureValue
      moveRes.status mustBe FORBIDDEN
    }

    "successfully move some nodes and fail for others when MuseumId is invalid" in {
      val anotherMid   = MuseumId(4)
      val anotherToken = BearerToken(FakeUsers.nhmAdminToken)

      val targetJs = storageUnitJson("Target", StorageNodeDatabaseId(7))
      val target   = postNode(mid, adminToken, targetJs)

      val json1 = storageUnitJson("Move me1", StorageNodeDatabaseId(34))
      val mn1   = postNode(mid, adminToken, json1)

      val json2 = storageUnitJson("Move me2", StorageNodeDatabaseId(34))
      val mn2   = postNode(mid, adminToken, json2)

      val orgJs = organisationJson("Hanky", Some(StorageNodeDatabaseId(21)))
      val org   = postNode(anotherMid, anotherToken, orgJs)
      val orgId = getIdStringFor(org._2)

      val buildJs = buildingJson("Panky", StorageNodeDatabaseId(org._2))
      val build   = postNode(anotherMid, anotherToken, buildJs)
      val bid     = getIdStringFor(build._2)

      val json3 = storageUnitJson("Move me3", StorageNodeDatabaseId(build._2))
      val mn3   = postNode(anotherMid, anotherToken, json3)

      val id1 = getIdStringFor(mn1._2)
      val id2 = getIdStringFor(mn2._2)
      val id3 = getIdStringFor(mn3._2)

      val moveJson = Json.parse(
        s"""{
             |  "doneBy": "${adminId.asString}",
             |  "destination": "${getIdStringFor(target._2)}",
             |  "items": ["$id1", "$id2", "$id3"]
             |}""".stripMargin
      )

      val move = wsUrl(MoveStorageNodeUrl(mid))
        .withHeaders(writeToken.asHeader)
        .put(moveJson)
        .futureValue

      move.status mustBe OK

      (move.json \ "moved")
        .as[JsArray]
        .value
        .map(_.as[String]) must contain allOf (id1, id2)
      (move.json \ "failed").as[JsArray].value.map(_.as[String]) must contain(id3)

      val movedRes1 =
        wsUrl(StorageNodeUrl(mid, id1)).withHeaders(readToken.asHeader).get().futureValue
      val movedRes2 =
        wsUrl(StorageNodeUrl(mid, id2)).withHeaders(readToken.asHeader).get().futureValue
      val movedRes3 = wsUrl(StorageNodeUrl(anotherMid, id3))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue

      val n1 = verifyNode[StorageUnit](
        movedRes1,
        StorageUnitType,
        "Move me1",
        mn1._2,
        Some(target._2)
      )
      val n2 = verifyNode[StorageUnit](
        movedRes2,
        StorageUnitType,
        "Move me2",
        mn2._2,
        Some(target._2)
      )
      val n3 = verifyNode[StorageUnit](
        movedRes3,
        StorageUnitType,
        "Move me3",
        mn3._2,
        Some(StorageNodeDatabaseId(build._2))
      )

      n1.path mustBe NodePath(s",1,3,4,7,${target._2},${mn1._2},")
      n2.path mustBe NodePath(s",1,3,4,7,${target._2},${mn2._2},")
      n3.path mustBe NodePath(s",21,43,44,${mn3._2},")
    }

    "find a storage when searching by name" in {
      val res1 = wsUrl(StorageNodeSearchName(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "My Buil")
        .get()
        .futureValue

      res1.status mustBe OK
      res1.json.as[JsArray].value must not be empty

      val res2 = wsUrl(StorageNodeSearchName(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "My R")
        .get()
        .futureValue

      res2.status mustBe OK
      res2.json.as[JsArray].value must not be empty
    }

    "return no results when searching for storage name that doesn't exist" in {
      val res = wsUrl(StorageNodeSearchName(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "My_private_building")
        .get()
        .futureValue

      res.status mustBe OK
      res.json.as[JsArray].value mustBe empty
    }

    "return no data when searching for node by name when using the wrong MuseumId" in {
      val anotherMid = MuseumId(4)
      val res = wsUrl(StorageNodeSearchName(anotherMid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "My Buil")
        .get()
        .futureValue

      res.status mustBe OK
      res.json.as[JsArray].value mustBe empty
    }

    "return 400 when searching for node by name using less than 3 characters" in {
      wsUrl(StorageNodeSearchName(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "My")
        .get()
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "return 400 when searching by name with no search criteria" in {
      wsUrl(StorageNodeSearchName(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "")
        .get()
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "find a node when searching by name with three chars and the third is blank" in {
      val res1 = wsUrl(StorageNodeSearchName(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("searchStr" -> "My ")
        .get()
        .futureValue

      res1.status mustBe OK
      res1.json.as[JsArray].value must not be empty
    }
  }

  "scanning barcodes" should {
    "find a storage node when calling the scan service with a UUID" in {
      val uuid = "244f09a3-eb1a-49e7-80ee-7a07baa016dd"

      val res = wsUrl(ScanUrl(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("storageNodeId" -> uuid)
        .get()
        .futureValue

      res.status mustBe OK
      (res.json \ "name").as[String] mustBe "Naturværelset"
      (res.json \ "type").as[String] mustBe "Room"
    }

    "find a storage node when calling the scan service with an old barcode" in {
      val oldBarcode = 11111111

      val res = wsUrl(ScanUrl(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("oldBarcode" -> s"$oldBarcode")
        .get()
        .futureValue

      res.status mustBe OK
      (res.json \ "name").as[String] mustBe "TestRoom 1"
      (res.json \ "type").as[String] mustBe "Room"
    }

    "return BadRequest if none of the query params are specified" in {
      wsUrl(ScanUrl(mid))
        .withHeaders(readToken.asHeader)
        .get()
        .futureValue
        .status mustBe BAD_REQUEST
    }

    "return BadRequest if storageNodeId isn't a valid UUID" in {
      wsUrl(ScanUrl(mid))
        .withHeaders(readToken.asHeader)
        .withQueryString("storageNodeId" -> "foo-bar-code")
        .get()
        .futureValue
        .status mustBe BAD_REQUEST
    }
  }

}
