/*
 * MUSIT is a museum database to archive natural and cultural history data.
 * Copyright (C) 2016  MUSIT Norway, part of www.uio.no (University of Oslo)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License,
 * or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

package controllers

import models.DummyData
import models.storage.StorageType._
import models.storage._
import no.uio.musit.formatters.DateTimeFormatters.dateTimeFormatter
import no.uio.musit.models.{MuseumId, NamedPathElement, NodePath, StorageNodeId}
import no.uio.musit.security.BearerToken
import no.uio.musit.security.FakeAuthenticator.fakeAccessTokenPrefix
import no.uio.musit.test.MusitSpecWithServerPerSuite
import org.joda.time.DateTime
import org.scalatest.time.{Millis, Seconds, Span}
import play.api.libs.json._
import play.api.test.Helpers._
import play.api.libs.ws.WSResponse
import utils.testhelpers.StorageNodeJsonGenerator._
import utils.testhelpers._

/**
 * TODO: These tests are still somewhat fragile in that some of them
 * depend on ID's generated by the previously executed test cases.
 */
class StorageNodeResourceIntegrationSpec extends MusitSpecWithServerPerSuite {

  implicit override val patienceConfig: PatienceConfig = PatienceConfig(
    timeout = Span(15, Seconds),
    interval = Span(50, Millis)
  )

  def verifyNode[T <: StorageNode](
    response: WSResponse,
    expStorageType: StorageType,
    expName: String,
    expId: Long,
    expPartOf: Option[Long] = None
  )(implicit manifest: Manifest[T]): T = {
    val storageNode = parseAndVerifyResponse[T](response)
    // verifying common attributes across all storage node types
    storageNode.id mustBe Some(StorageNodeId(expId))
    storageNode.storageType mustBe expStorageType
    storageNode.isPartOf mustBe expPartOf.map(StorageNodeId.apply)
    storageNode.name mustBe expName
    storageNode mustBe a[T]

    storageNode
  }

  def parseAndVerifyResponse[T](response: WSResponse): T = {
    val json = Json.parse(response.body)
    val parsed = json.validate[StorageNode]
    parsed.isSuccess mustBe true
    parsed.get.asInstanceOf[T]
  }

  val mid = MuseumId(1)

  val readToken = BearerToken(fakeAccessTokenPrefix + "musitTestUser")
  val writeToken = BearerToken(fakeAccessTokenPrefix + "musitTestUserKhmWrite")
  val adminToken = BearerToken(fakeAccessTokenPrefix + "musitTestUserKhmAdmin")
  val godToken = BearerToken(fakeAccessTokenPrefix + "superuser")

  // TODO: add override def beforeTests to bootstrap a re-usable structure to
  // avoid boilerplate bootstrapping in all the tests.

  "Running the storage facility service" when {

    "interacting with the StorageUnitResource endpoints" should {

      "successfully create a few root nodes" in {

        def genAndAddRootNode(mid: Int, numNodes: Int, from: Int = 1): Seq[Root] = {
          val fromIncInserted = from + 6
          val addedNodes = Seq.newBuilder[Root]
          for (i <- fromIncInserted until numNodes + fromIncInserted) {
            val res = wsUrl(RootNodeUrl(mid))
              .withHeaders(godToken.asHeader)
              .post(JsNull).futureValue
            val root = parseAndVerifyResponse[Root](res)
            root mustBe a[Root]
            root.id.isEmpty must not be true
            root.id.get mustBe StorageNodeId(i.toLong)
            root.storageType mustBe StorageType.RootType
            val rootId = root.id.get
            root.path mustBe NodePath(s",${rootId.underlying},")
            addedNodes += root
          }
          addedNodes.result()
        }

        genAndAddRootNode(mid, 2).size mustBe 2
        genAndAddRootNode(4, 2, 3).size mustBe 2
      }

      "successfully create an organisation node" in {
        val json = organisationJson("My Org1", Some(StorageNodeId(1)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val newOrg = parseAndVerifyResponse[Organisation](response)

        val organisation = verifyNode[Organisation](
          response, OrganisationType, "My Org1", 11, Some(1)
        )
        organisation mustBe an[Organisation]
        organisation.path mustBe NodePath(",1,11,")
        organisation.updatedBy mustBe Some(DummyData.DummyUserId)
        organisation.updatedDate.get.toString must include("2016")
      }

      "successfully create a building node" in {
        val json = buildingJson("My Building1", StorageNodeId(11))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val newBuilding = parseAndVerifyResponse[Building](response)
        val building = verifyNode[Building](
          response, BuildingType, "My Building1", 12, Some(11)
        )
        building mustBe a[Building]
        building.path mustBe NodePath(",1,11,12,")
        building.updatedBy.get mustBe DummyData.DummyUserId
        building.updatedDate.get.toString must include("2016")
      }

      "successfully create a room node" in {
        val json = roomJson("My Room1", Some(StorageNodeId(12)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val newRoom = parseAndVerifyResponse[Room](response)
        val room = verifyNode[Room](
          response, RoomType, "My Room1", 13, Some(12)
        )
        room mustBe a[Room]
        room.path mustBe NodePath(",1,11,12,13,")
        room.updatedBy.get mustBe DummyData.DummyUserId
        room.updatedDate.get.toString must include("2016")
      }

      "successfully create a storage unit node" in {
        val json = storageUnitJson("My Shelf1", StorageNodeId(13))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val newStorageNode = parseAndVerifyResponse[StorageUnit](response)
        val su = verifyNode[StorageUnit](
          response, StorageUnitType, "My Shelf1", 14, Some(13)
        )
        su mustBe a[StorageUnit]
        su.path mustBe NodePath(",1,11,12,13,14,")
        su.updatedBy.get mustBe DummyData.DummyUserId
        su.updatedDate.get.toString must include("2016")
      }

      "not allow creating a storage node with a name over 100 chars" in {
        val json = storageUnitJson(HundredAndOneCharString, StorageNodeId(7))
        wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue.status mustBe BAD_REQUEST
      }

      "not allow creating a building with an address over 100 chars" in {
        val bjs = buildingJson("fail", StorageNodeId(3))
        val json = bjs.as[JsObject] ++ Json.obj("address" -> HundredAndOneCharString)
        wsUrl(StorageNodesUrl(mid.underlying))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue.status mustBe BAD_REQUEST
      }

      "successfully get an organisation" in {
        val response = wsUrl(StorageNodeUrl(mid, 11))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        response.status mustBe OK

        val organisation = verifyNode[Organisation](
          response, OrganisationType, "My Org1", 11, Some(1)
        )
        organisation mustBe an[Organisation]
      }

      "successfully get a building" in {
        val response = wsUrl(StorageNodeUrl(mid, 12))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        response.status mustBe OK

        val building = verifyNode[Building](
          response, BuildingType, "My Building1", 12, Some(11)
        )
        building mustBe a[Building]
      }

      "successfully get a room" in {
        val response = wsUrl(StorageNodeUrl(mid, 13))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        response.status mustBe OK

        val room = verifyNode[Room](
          response, RoomType, "My Room1", 13, Some(12)
        )
        room mustBe a[Room]
        room.environmentRequirement must not be None
        room.path mustBe NodePath(",1,11,12,13,")
        room.pathNames must not be None
        room.pathNames.value must contain allOf (
          NamedPathElement(StorageNodeId(1), "root-node"),
          NamedPathElement(StorageNodeId(11), "My Org1"),
          NamedPathElement(StorageNodeId(12), "My Building1"),
          NamedPathElement(StorageNodeId(13), "My Room1")
        )
      }

      "successfully get a storage unit" in {
        val response = wsUrl(StorageNodeUrl(mid, 14))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        response.status mustBe OK

        val su = verifyNode[StorageUnit](
          response, StorageUnitType, "My Shelf1", 14, Some(13)
        )
        su mustBe a[StorageUnit]
        su.environmentRequirement must not be None
      }

      "not find a storage node with an invalid Id" in {
        wsUrl(StorageNodeUrl(mid, 9999))
          .withHeaders(readToken.asHeader)
          .get().futureValue.status mustBe NOT_FOUND
      }

      "successfully update a storage unit" in {
        val json = storageUnitJson("My Shelf2", StorageNodeId(13))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val su = verifyNode[StorageUnit](
          response, StorageUnitType, "My Shelf2", 15, Some(13)
        )
        su mustBe a[StorageUnit]
        su.path mustBe NodePath(",1,11,12,13,15,")
        su.areaTo mustBe Some(.5)
        su.heightTo mustBe Some(.6)

        val updatedJson = {
          Json.parse(response.body).as[JsObject] ++ Json.obj(
            "name" -> "My Shelf2b",
            "areaTo" -> JsNumber(.8),
            "heightTo" -> JsNumber(.8)
          )
        }

        val updRes = wsUrl(StorageNodeUrl(mid, su.id.get))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe OK
        val updated = verifyNode[StorageUnit](
          updRes, StorageUnitType, "My Shelf2b", su.id.get, Some(13)
        )

        updated mustBe a[StorageUnit]
        updated.path mustBe NodePath(",1,11,12,13,15,")
        updated.areaTo mustBe Some(.8)
        updated.heightTo mustBe Some(.8)
        updated.updatedBy.get mustBe DummyData.DummyUpdatedUserId
      }

      "successfully update a room" in {
        val json = roomJson("My Room2", Some(StorageNodeId(12)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED

        val room = verifyNode[Room](
          response, RoomType, "My Room2", 16, Some(12)
        )
        room mustBe a[Room]
        room.path mustBe NodePath(",1,11,12,16,")
        room.areaTo mustBe Some(21.0)
        room.heightTo mustBe Some(2.6)

        val updatedJson = {
          Json.parse(response.body).as[JsObject] ++ Json.obj(
            "name" -> "My Room2b",
            "lightingCondition" -> true
          )
        }

        val updRes = wsUrl(StorageNodeUrl(mid, room.id.get))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe OK
        val updated = verifyNode[Room](
          updRes, RoomType, "My Room2b", room.id.get, Some(12)
        )

        updated mustBe a[Room]
        updated.path mustBe NodePath(",1,11,12,16,")
        updated.environmentAssessment.lightingCondition mustBe Some(true)
        updated.pathNames must not be None
        updated.pathNames.value must contain allOf (
          NamedPathElement(StorageNodeId(1), "root-node"),
          NamedPathElement(StorageNodeId(11), "My Org1"),
          NamedPathElement(StorageNodeId(12), "My Building1"),
          NamedPathElement(StorageNodeId(16), "My Room2b")
        )
        updated.updatedBy.get mustBe DummyData.DummyUpdatedUserId
      }

      "successfully update a building with environment requirements" in {
        val json = buildingJson("My Building2", StorageNodeId(11))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val building = verifyNode[Building](
          response, BuildingType, "My Building2", 17, Some(11)
        )
        building mustBe a[Building]
        building.path mustBe NodePath(",1,11,17,")
        building.areaTo mustBe Some(210.0)
        building.heightTo mustBe Some(3.5)

        val updatedJson = {
          Json.parse(response.body).as[JsObject] ++ Json.obj(
            "address" -> "Fjære Åker Øya 21, 2341 Huttiheita, Norge",
            "environmentRequirement" -> Json.parse(envReqJson("Filthy"))
          )
        }

        val updRes = wsUrl(StorageNodeUrl(mid, building.id.get))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe OK
        val updated = verifyNode[Building](
          updRes, BuildingType, "My Building2", building.id.get, Some(11)
        )

        updated mustBe a[Building]
        updated.path mustBe NodePath(",1,11,17,")
        updated.address mustBe Some("Fjære Åker Øya 21, 2341 Huttiheita, Norge")
        updated.environmentRequirement.isEmpty must not be true
        updated.environmentRequirement.get.cleaning mustBe Some("Filthy")
        updated.updatedBy.get mustBe DummyData.DummyUpdatedUserId

      }

      "successfully update an organisation" in {
        val json = organisationJson("My Organisation2", Some(StorageNodeId(1)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val organisation = verifyNode[Organisation](
          response, OrganisationType, "My Organisation2", 18, Some(1)
        )
        organisation mustBe an[Organisation]
        organisation.path mustBe NodePath(",1,18,")
        organisation.areaTo mustBe Some(2100)
        organisation.heightTo mustBe Some(3.5)

        val updatedJson = {
          Json.parse(response.body).as[JsObject] ++ Json.obj(
            "address" -> "Fjære Åker Øya 21, 2341 Huttiheita, Norge"
          )

        }

        val updRes = wsUrl(StorageNodeUrl(mid, organisation.id.get))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe OK
        val updated = verifyNode[Organisation](
          updRes, OrganisationType, "My Organisation2", organisation.id.get, organisation.isPartOf
        )

        updated mustBe an[Organisation]
        updated.path mustBe NodePath(",1,18,")
        updated.address mustBe Some("Fjære Åker Øya 21, 2341 Huttiheita, Norge")
        updated.updatedBy.get mustBe DummyData.DummyUpdatedUserId
      }

      "respond with 404 when trying to update a node that doesn't exist" in {
        val json = storageUnitJson("Non existent", StorageNodeId(3))
        wsUrl(StorageNodeUrl(mid, 999))
          .withHeaders(adminToken.asHeader)
          .put(json).futureValue.status mustBe NOT_FOUND
      }

      "list all children for a node with correct storage types" in {
        val res = wsUrl(NodeChildrenUrl(mid, 1))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        res.status mustBe OK
        res.json.as[JsArray].value.foreach { jsv =>
          (jsv \ "type").as[String] mustBe "Organisation"
        }

      }

      "successfully delete a storage node" in {
        val json = storageUnitJson("Remove me", StorageNodeId(13))
        val res = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        val created = verifyNode[StorageUnit](
          res, StorageUnitType, "Remove me", 19, Some(13)
        )

        created mustBe a[StorageUnit]

        val rmRes = wsUrl(StorageNodeUrl(mid, created.id.get))
          .withHeaders(adminToken.asHeader)
          .delete().futureValue
        rmRes.status mustBe OK

        val notFound = wsUrl(StorageNodeUrl(mid, created.id.get))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        notFound.status mustBe NOT_FOUND
      }

      "respond with 404 when deleting a node that doesn't exist" in {
        wsUrl(StorageNodeUrl(mid, 9999))
          .withHeaders(adminToken.asHeader)
          .delete().futureValue.status mustBe NOT_FOUND
      }

      "respond with 404 when deleting a node that is already deleted" in {
        wsUrl(StorageNodeUrl(mid, 19))
          .withHeaders(adminToken.asHeader)
          .delete().futureValue.status mustBe NOT_FOUND
      }

      "respond with 404 when updating a node that is deleted" in {
        val json = {
          storageUnitJson("Remove me", StorageNodeId(7)).as[JsObject] ++ Json.obj(
            "id" -> 13,
            "name" -> "Hakuna Matata"
          )
        }
        wsUrl(StorageNodeUrl(mid, 13))
          .withHeaders(adminToken.asHeader)
          .put(json).futureValue.status mustBe NOT_FOUND
      }

      "successfully move a single node" in {
        val json = storageUnitJson("Move me", StorageNodeId(13))
        val res = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        val created = verifyNode[StorageUnit](
          res, StorageUnitType, "Move me", 20, Some(13)
        )

        created mustBe a[StorageUnit]
        created.path mustBe NodePath(",1,11,12,13,20,")

        val moveMeId = created.id.get.underlying
        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 15,
              |  "items": [${created.id.get.underlying}]
              |}""".stripMargin
        )

        val moveRes = wsUrl(MoveStorageNodeUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        moveRes.status mustBe OK

        (moveRes.json \ "moved").as[JsArray].value.head.as[Long] mustBe moveMeId

        val movedNodeRes = wsUrl(StorageNodeUrl(mid, moveMeId))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        val moved = verifyNode[StorageUnit](
          movedNodeRes, StorageUnitType, "Move me", moveMeId, Some(15)
        )
        moved mustBe a[StorageUnit]
        moved.path mustBe NodePath(",1,11,12,13,15,20,")
      }

      "fail when trying to move a node to an invalid destination" in {
        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 20,
              |  "items": [13]
              |}""".stripMargin
        )
        wsUrl(MoveStorageNodeUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue.status mustBe BAD_REQUEST
      }

      "successfully move several nodes" in {
        val json1 = storageUnitJson("Move me1", StorageNodeId(13))
        val res1 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json1).futureValue
        val json2 = storageUnitJson("Move me2", StorageNodeId(13))
        val res2 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json2).futureValue
        val json3 = storageUnitJson("Move me3", StorageNodeId(13))
        val res3 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json3).futureValue

        res1.status mustBe CREATED
        res2.status mustBe CREATED
        res3.status mustBe CREATED

        val id1 = (res1.json \ "id").as[Long]
        val id2 = (res2.json \ "id").as[Long]
        val id3 = (res3.json \ "id").as[Long]

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 15,
              |  "items": [$id1, $id2, $id3]
              |}""".stripMargin
        )

        val move = wsUrl(MoveStorageNodeUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        move.status mustBe OK

        val movedRes1 = wsUrl(StorageNodeUrl(mid, id1))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        val movedRes2 = wsUrl(StorageNodeUrl(mid, id2))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        val movedRes3 = wsUrl(StorageNodeUrl(mid, id3))
          .withHeaders(readToken.asHeader)
          .get().futureValue

        val n1 = verifyNode[StorageUnit](
          movedRes1, StorageUnitType, "Move me1", id1, Some(15)
        )
        val n2 = verifyNode[StorageUnit](
          movedRes2, StorageUnitType, "Move me2", id2, Some(15)
        )
        val n3 = verifyNode[StorageUnit](
          movedRes3, StorageUnitType, "Move me3", id3, Some(15)
        )

        n1.path mustBe NodePath(s",1,11,12,13,15,$id1,")
        n2.path mustBe NodePath(s",1,11,12,13,15,$id2,")
        n3.path mustBe NodePath(s",1,11,12,13,15,$id3,")
      }

      "fail when trying to move several nodes to an invalid destination" in {
        val json1 = storageUnitJson("Move me1", StorageNodeId(13))
        val res1 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json1).futureValue
        val json2 = storageUnitJson("Move me2", StorageNodeId(13))
        val res2 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json2).futureValue
        val json3 = storageUnitJson("Move me3", StorageNodeId(13))
        val res3 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json3).futureValue

        res1.status mustBe CREATED
        res2.status mustBe CREATED
        res3.status mustBe CREATED

        val id1 = (res1.json \ "id").as[Long]
        val id2 = (res2.json \ "id").as[Long]
        val id3 = (res3.json \ "id").as[Long]

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 1,
              |  "items": [$id1, $id2, $id3]
              |}""".stripMargin
        )
        wsUrl(MoveStorageNodeUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue.status mustBe BAD_REQUEST
      }

      "successfully move a node and all its children" in {
        val res1 = wsUrl(NodeChildrenUrl(mid, 15))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        res1.status mustBe OK
        val directChildIds = res1.json.as[JsArray].value.map { jsv =>
          (jsv \ "id").as[Long]
        }

        val subChildrenIds = directChildIds.flatMap { id =>
          val r = wsUrl(NodeChildrenUrl(mid, id))
            .withHeaders(readToken.asHeader)
            .get().futureValue
          r.status mustBe OK
          r.json.as[JsArray].value.map { jsv =>
            (jsv \ "id").as[Long]
          }
        }

        val verifyIds = directChildIds ++ subChildrenIds
        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 14,
              |  "items": [15]
              |}""".stripMargin
        )

        val moveRes = wsUrl(MoveStorageNodeUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        moveRes.status mustBe OK
        (moveRes.json \ "moved").as[JsArray].value.map(_.as[Int]) must contain(15)

        val paths = verifyIds.map { id =>
          val r = wsUrl(StorageNodeUrl(mid, id))
            .withHeaders(readToken.asHeader)
            .get().futureValue
          r.status mustBe OK
          (
            (r.json \ "id").as[Int],
            (r.json \ "path").as[String],
            (r.json \ "isPartOf").asOpt[Int]
          )
        }
      }

      "successfully move several objects" in {
        val id1 = 1
        val id2 = 2
        val id3 = 3

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 5,
              |  "items": [$id1, $id2, $id3]
              |}""".stripMargin
        )

        val move = wsUrl(MoveObjectUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        move.status mustBe OK
        (move.json \ "moved").as[JsArray].value.map(_.as[Int]) must contain allOf (id1, id2, id3)
      }

      "successfully move a single object" in {
        val res = wsUrl(ObjLocationHistoryUrl(mid, 2))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        val id2 = 2

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 3,
              |  "items": [$id2]
              |}""".stripMargin
        )
        val move = wsUrl(MoveObjectUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        move.status mustBe OK
        (move.json \ "moved").as[JsArray].value.head.as[Long] mustBe id2
      }

      "successfully fetch the location history for a given object" in {
        val res = wsUrl(ObjLocationHistoryUrl(mid, 2))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        res.status mustBe OK
        val resArr = res.json.as[JsArray].value
        resArr must not be empty
        resArr.size mustBe 2

        val today = DateTime.now.withTimeAtStartOfDay()

        val firstElem = resArr.head
        (firstElem \ "doneDate").as[DateTime] mustBe today
        (firstElem \ "doneBy").as[Int] mustBe 1
        (firstElem \ "registeredDate").as[DateTime].withTimeAtStartOfDay() mustBe today
        (firstElem \ "registeredBy").as[String] mustBe "Darth Vader"
        (firstElem \ "from" \ "path").as[NodePath] mustBe NodePath(",1,2,3,5,")
        (firstElem \ "from" \ "pathNames").as[JsArray].value must not be empty
        (firstElem \ "to" \ "path").as[NodePath] mustBe NodePath(",1,2,3,")
        (firstElem \ "to" \ "pathNames").as[JsArray].value must not be empty

        val lastElem = resArr.last
        (lastElem \ "doneDate").as[DateTime] mustBe today
        (lastElem \ "doneBy").as[Int] mustBe 1
        (lastElem \ "registeredDate").as[DateTime].withTimeAtStartOfDay() mustBe today
        (lastElem \ "registeredBy").as[String] mustBe "Darth Vader"
        (lastElem \ "from" \ "path").as[NodePath] mustBe NodePath(",1,2,3,4,")
        (lastElem \ "from" \ "pathNames").as[JsArray].value must not be empty
        (lastElem \ "to" \ "path").as[NodePath] mustBe NodePath(",1,2,3,5,")
        (lastElem \ "to" \ "pathNames").as[JsArray].value must not be empty
      }

      "successfully get currentLocation of a single object" in {
        val id2 = 2

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 3,
              |  "items": [$id2]
              |}""".stripMargin
        )

        val move = wsUrl(MoveObjectUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        move.status mustBe OK
        (move.json \ "moved").as[JsArray].value.head.as[Long] mustBe id2

        val currentLocation = wsUrl(ObjCurrentLocationUrl(mid, 2))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        currentLocation.status mustBe OK
      }

      "respond with 403 when trying to get an organisation with wrong museum" in {
        val mid = MuseumId(5)
        val json = storageUnitJson("Non existent museum", StorageNodeId(5))
        val failedUpdate = wsUrl(StorageNodeUrl(mid, 5))
          .withHeaders(writeToken.asHeader)
          .put(json).futureValue
        failedUpdate.status mustBe FORBIDDEN
      }

      "respond with 400 when trying to get an building with a museum that not exist" in {
        val mid = MuseumId(55)
        val json = storageUnitJson("Non existent museum", StorageNodeId(6))

        val failedUpdate = wsUrl(StorageNodeUrl(mid, 6))
          .withHeaders(writeToken.asHeader)
          .put(json).futureValue
        failedUpdate.status mustBe BAD_REQUEST
      }

      "Not list all children for a rootnode with museumId that not exist" in {
        val mid = MuseumId(55)
        val res = wsUrl(NodeChildrenUrl(mid, 1))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        res.status mustBe BAD_REQUEST
      }

      "Not list all children for a rootnode with wrong museumId " in {
        val mid = MuseumId(3)
        val res = wsUrl(NodeChildrenUrl(mid, 1))
          .withHeaders(readToken.asHeader)
          .get().futureValue

        res.status mustBe OK
        res.json.as[JsArray].value.size mustBe 0
      }

      "not be able to get an organisation node when the MuseumId doesn't exists" in {
        val json = organisationJson("My Org1", Some(StorageNodeId(1)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]
        val notExistsMid = MuseumId(44)

        val notExistsRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        notExistsRes.status mustBe BAD_REQUEST
        val wrongMid = MuseumId(4)
        val wrongRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        wrongRes.status mustBe NOT_FOUND
        // have to fill in later when auth-object is implemented.
      }

      "not be able to get a building node when the MuseumId doesn't exists" in {
        val json = buildingJson("My Building1", StorageNodeId(5))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]
        val notExistsMid = MuseumId(44)

        val notExistsRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        notExistsRes.status mustBe BAD_REQUEST
        val wrongMid = MuseumId(4)
        val wrongRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        wrongRes.status mustBe NOT_FOUND
        // have to fill in later when auth-object is implemented.
      }

      "not be able to get a room node when the MuseumId doesn't exists" in {
        val json = roomJson("My Room1", Some(StorageNodeId(6)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]
        val notExistsMid = MuseumId(44)

        val notExistsRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        notExistsRes.status mustBe BAD_REQUEST
        val wrongMid = MuseumId(4)
        val wrongRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        wrongRes.status mustBe NOT_FOUND
        // TODO: have to fill in later when auth-object is implemented.
      }

      "not be able get a storage unit node when the MuseumId doesn't exists" in {
        val json = storageUnitJson("My Shelf1", StorageNodeId(29))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]
        val notExistsMid = MuseumId(44)

        val notExistsRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        notExistsRes.status mustBe BAD_REQUEST
        val wrongMid = MuseumId(4)
        val wrongRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        wrongRes.status mustBe NOT_FOUND
        // TODO: have to fill in later when auth-object is implemented.
      }

      "not update a storage unit when the MuseumId isn't correct" in {
        val json = storageUnitJson("My Shelf2", StorageNodeId(6))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]

        val updatedJson = {
          response.json.as[JsObject] ++ Json.obj(
            "name" -> "My Shelf2b",
            "areaTo" -> JsNumber(.8),
            "heightTo" -> JsNumber(.8)
          )
        }
        val wrongMid = MuseumId(4)
        val updRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe FORBIDDEN

        val notExistsMid = MuseumId(55)
        val notExistsupdRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        notExistsupdRes.status mustBe BAD_REQUEST

        val checkOldRes = wsUrl(StorageNodeUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        checkOldRes.status mustBe OK
        checkOldRes.json mustBe response.json
      }

      "not update a room when the MuseumId isn't correct" in {
        val json = roomJson("My Room2", Some(StorageNodeId(6)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]

        val updatedJson = {
          response.json.as[JsObject] ++ Json.obj(
            "name" -> "My Room2b",
            "lightingCondition" -> false,
            "waterDamage" -> false
          )
        }
        val wrongMid = MuseumId(4)
        val updRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe FORBIDDEN
        val notExistsMid = MuseumId(55)
        val notExistsupdRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        notExistsupdRes.status mustBe BAD_REQUEST

        val checkOldRes = wsUrl(StorageNodeUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        checkOldRes.status mustBe OK
        checkOldRes.json mustBe response.json
      }

      "not update a building or its env requirements when the MuseumId isn't correct" in {
        val json = buildingJson("My Building2", StorageNodeId(5))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]

        val updatedJson = {
          response.json.as[JsObject] ++ Json.obj(
            "address" -> "Fjære Åker Norge",
            "environmentRequirement" -> Json.parse(envReqJson("Filthy"))
          )
        }
        val wrongMid = MuseumId(4)
        val updRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe FORBIDDEN
        val NotExistsMid = MuseumId(55)
        val notExistsupdRes = wsUrl(StorageNodeUrl(NotExistsMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        notExistsupdRes.status mustBe BAD_REQUEST

        val checkOldRes = wsUrl(StorageNodeUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        checkOldRes.status mustBe OK
        checkOldRes.json mustBe response.json
      }

      "not update an organisation when the MuseumId isn't correct" in {
        val json = organisationJson("My Organisation2", Some(StorageNodeId(1)))
        val response = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        response.status mustBe CREATED
        val id = (response.json \ "id").as[Long]

        val updatedJson = {
          response.json.as[JsObject] ++ Json.obj(
            "address" -> "Fjære xxxx Huttiheita, Norge"
          )
        }
        val wrongMid = MuseumId(4)
        val updRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        updRes.status mustBe FORBIDDEN

        val notExistsMid = MuseumId(55)
        val notExistsupdRes = wsUrl(StorageNodeUrl(notExistsMid, id))
          .withHeaders(adminToken.asHeader)
          .put(updatedJson).futureValue
        notExistsupdRes.status mustBe BAD_REQUEST

        val checkOldRes = wsUrl(StorageNodeUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        checkOldRes.status mustBe OK
        checkOldRes.json mustBe response.json
      }

      "respond with 403 when trying to update a node using wrong MuseumId" in {
        val res = wsUrl(StorageNodeUrl(mid, 31))
          .withHeaders(readToken.asHeader)
          .get.futureValue
        res.status mustBe OK
        val wrongMid = MuseumId(5)
        val err = wsUrl(StorageNodeUrl(wrongMid, 31))
          .withHeaders(adminToken.asHeader)
          .put(res.json).futureValue
        err.status mustBe FORBIDDEN
      }

      "respond with 403 when trying to list all children in an unauthorized museum" in {
        wsUrl(NodeChildrenUrl(MuseumId(6), 1))
          .withHeaders(readToken.asHeader)
          .get().futureValue.status mustBe FORBIDDEN
      }

      "not delete a storage node when the museumId is incorrect" in {
        val json = storageUnitJson("Remove me", StorageNodeId(30))
        val res1 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        res1.status mustBe CREATED
        val id = (res1.json \ "id").as[Long]

        val wrongMid = MuseumId(4)
        val rmRes = wsUrl(StorageNodeUrl(wrongMid, id))
          .withHeaders(adminToken.asHeader)
          .delete().futureValue
        rmRes.status mustBe FORBIDDEN

        val res2 = wsUrl(StorageNodeUrl(mid, id))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        res2.status mustBe OK
        res2.json mustBe res1.json
      }

      "respond with 400 when trying to delete a node using an invalid museumId" in {
        val notExistsMid = MuseumId(55)
        wsUrl(StorageNodeUrl(notExistsMid, 9999))
          .withHeaders(adminToken.asHeader)
          .delete().futureValue.status mustBe BAD_REQUEST
      }

      "respond with 403 when trying to delete an already deleted node using " +
        "the wrong MuseumId" in {
          val rmRes = wsUrl(StorageNodeUrl(mid, 32))
            .withHeaders(adminToken.asHeader)
            .delete().futureValue
          rmRes.status mustBe OK

          val wrongMid = MuseumId(4)
          val rmRes1 = wsUrl(StorageNodeUrl(wrongMid, 32))
            .withHeaders(adminToken.asHeader)
            .delete().futureValue
          rmRes1.status mustBe FORBIDDEN
        }

      "respond with 403 when trying to update a deleted node in a museum " +
        "without authorization" in {
          val mid = MuseumId(2)
          val json = {
            storageUnitJson("Remove me", StorageNodeId(7)).as[JsObject] ++ Json.obj(
              "id" -> 26,
              "name" -> "Hakuna Matata"
            )
          }

          wsUrl(StorageNodeUrl(mid, 32))
            .withHeaders(adminToken.asHeader)
            .put(json).futureValue.status mustBe FORBIDDEN
        }

      "not move a node when museumId is incorrect" in {
        val json = storageUnitJson("Move me", StorageNodeId(6))
        val res1 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json).futureValue
        res1.status mustBe CREATED

        val moveMeId = (res1.json \ "id").as[Long]
        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 29,
              |  "items": [$moveMeId]
              |}""".stripMargin
        )

        val wrongMid = MuseumId(4)
        val moveRes = wsUrl(MoveStorageNodeUrl(wrongMid))
          .withHeaders(adminToken.asHeader)
          .put(moveJson).futureValue
        moveRes.status mustBe FORBIDDEN

        val res2 = wsUrl(StorageNodeUrl(mid, moveMeId))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        res2.status mustBe OK
        (res2.json \ "path").as[NodePath] mustBe NodePath(s",1,2,3,6,$moveMeId,")

      }

      "successfully move some nodes and fail for others when museumId is invalid" in {
        val anotherMid = MuseumId(4)
        val anotherToken = BearerToken(fakeAccessTokenPrefix + "musitTestUserNhmAdmin")

        val json1 = storageUnitJson("Move me1", StorageNodeId(33))
        val res1 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json1).futureValue

        val json2 = storageUnitJson("Move me2", StorageNodeId(33))
        val res2 = wsUrl(StorageNodesUrl(mid))
          .withHeaders(adminToken.asHeader)
          .post(json2).futureValue

        val o3 = wsUrl(StorageNodesUrl(anotherMid))
          .withHeaders(anotherToken.asHeader)
          .post(organisationJson("Hanky", Some(StorageNodeId(10)))).futureValue
        o3.status mustBe CREATED
        val o3Id = (o3.json \ "id").as[Long]

        val b3 = wsUrl(StorageNodesUrl(anotherMid))
          .withHeaders(anotherToken.asHeader)
          .post(buildingJson("Panky", StorageNodeId(o3Id))).futureValue
        b3.status mustBe CREATED
        val b3Id = (b3.json \ "id").as[Long]

        val json3 = storageUnitJson("Move me3", StorageNodeId(b3Id))
        val res3 = wsUrl(StorageNodesUrl(anotherMid))
          .withHeaders(anotherToken.asHeader)
          .post(json3).futureValue

        res1.status mustBe CREATED
        res2.status mustBe CREATED
        res3.status mustBe CREATED

        val id1 = (res1.json \ "id").as[Long]
        val id2 = (res2.json \ "id").as[Long]
        val id3 = (res3.json \ "id").as[Long]

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 29,
              |  "items": [$id1, $id2, $id3]
              |}""".stripMargin
        )

        val move = wsUrl(MoveStorageNodeUrl(mid))
          .withHeaders(writeToken.asHeader)
          .put(moveJson).futureValue
        move.status mustBe OK

        (move.json \ "moved").as[JsArray].value.head.as[Long] mustBe id1
        (move.json \ "failed").as[JsArray].value.head.as[Long] mustBe id3

        val movedRes1 = wsUrl(StorageNodeUrl(mid, id1))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        val movedRes2 = wsUrl(StorageNodeUrl(mid, id2))
          .withHeaders(readToken.asHeader)
          .get().futureValue
        val movedRes3 = wsUrl(StorageNodeUrl(anotherMid, id3))
          .withHeaders(readToken.asHeader)
          .get().futureValue

        val n1 = verifyNode[StorageUnit](
          movedRes1, StorageUnitType, "Move me1", id1, Some(29)
        )
        val n2 = verifyNode[StorageUnit](
          movedRes2, StorageUnitType, "Move me2", id2, Some(29)
        )
        val n3 = verifyNode[StorageUnit](
          movedRes3, StorageUnitType, "Move me3", id3, Some(StorageNodeId(b3Id))
        )

        n1.path mustBe NodePath(s",1,2,3,6,29,$id1,")
        n2.path mustBe NodePath(s",1,2,3,6,29,$id2,")
        n3.path mustBe NodePath(s",10,39,40,$id3,")
      }

      /* "successfully and UnSuccesfully move several objects with different MuseumId " in {
     TODO: This test is pending until we can insert object with different museumId
        val mid = 2
        val id1 = 1234
        val id2 = 5678
        val id3 = 9876

        val moveJson = Json.parse(
          s"""{
              |  "doneBy": 1,
              |  "destination": 9,
              |  "items": [$id1, $id2, $id3]
              |}""".stripMargin
        )

        val move = wsUrl(MoveObjectUrl(mid))
          .withHeaders(fakeToken.asHeader)
          .put(moveJson).futureValue

        move.status mustBe OK
        println(Json.prettyPrint(move.json))

        (move.json \ "moved").as[JsArray].value.map(_.as[Int]) must contain allOf (id1, id2, id3)
      }*/

      "find a storage when searching by name" in {
        val res1 = wsUrl(StorageNodeSearchName(mid))
          .withHeaders(readToken.asHeader)
          .withQueryString("searchStr" -> "My Buil")
          .get().futureValue

        res1.status mustBe OK
        res1.json.as[JsArray].value must not be empty

        val res2 = wsUrl(StorageNodeSearchName(mid))
          .withHeaders(readToken.asHeader)
          .withQueryString("searchStr" -> "My R")
          .get().futureValue

        res2.status mustBe OK
        res2.json.as[JsArray].value must not be empty
      }

      "return no results when searching for storage name that doesn't exist" in {
        val res = wsUrl(StorageNodeSearchName(mid))
          .withHeaders(readToken.asHeader)
          .withQueryString("searchStr" -> "My_private_building")
          .get().futureValue

        res.status mustBe OK
        res.json.as[JsArray].value mustBe empty
      }

      "return no data when searching for node by name when using the wrong MuseumId" in {
        val anotherMid = MuseumId(4)
        val res = wsUrl(StorageNodeSearchName(anotherMid))
          .withHeaders(readToken.asHeader)
          .withQueryString("searchStr" -> "My Buil")
          .get().futureValue

        res.status mustBe OK
        res.json.as[JsArray].value mustBe empty
      }

      "return 400 when searching for node by name using less than 3 characters" in {
        wsUrl(StorageNodeSearchName(mid))
          .withHeaders(readToken.asHeader)
          .withQueryString("searchStr" -> "My")
          .get().futureValue.status mustBe BAD_REQUEST
      }

      "return 400 when searching by name with no search criteria" in {
        wsUrl(StorageNodeSearchName(mid))
          .withHeaders(readToken.asHeader)
          .withQueryString("searchStr" -> "")
          .get().futureValue.status mustBe BAD_REQUEST
      }
      "find a storage when searching by name with three characters and the " +
        "third is blank" in {
          val res1 = wsUrl(StorageNodeSearchName(mid))
            .withHeaders(readToken.asHeader)
            .withQueryString("searchStr" -> "My ")
            .get().futureValue

          res1.status mustBe OK
          res1.json.as[JsArray].value must not be empty
        }
    }
  }
}
